# requirements.txt - Updated Python dependencies
Flask==2.3.3
Werkzeug==2.3.7
psutil==5.9.5
gunicorn==21.2.0

---
# .dockerignore - Optimize Docker builds
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.env
.git/
.gitignore
README.md
Dockerfile
.dockerignore
tests/
*.md

---
# scripts/deploy.sh - Deployment automation script
#!/bin/bash
set -e

echo "🚀 Deploying Flask App to EKS..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
CLUSTER_NAME=${CLUSTER_NAME:-flask-app-cluster}
NAMESPACE=${NAMESPACE:-flask-app}
IMAGE_TAG=${IMAGE_TAG:-latest}

# Functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    command -v kubectl >/dev/null 2>&1 || { log_error "kubectl is required but not installed."; exit 1; }
    command -v eksctl >/dev/null 2>&1 || { log_error "eksctl is required but not installed."; exit 1; }
    
    # Check cluster connectivity
    if ! kubectl cluster-info >/dev/null 2>&1; then
        log_error "Cannot connect to Kubernetes cluster"
        exit 1
    fi
    
    log_info "Prerequisites check passed ✅"
}

# Deploy application
deploy_app() {
    log_info "Deploying application to namespace: $NAMESPACE"
    
    # Create namespace if it doesn't exist
    kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
    
    # Apply all Kubernetes manifests
    kubectl apply -f k8s/ -n $NAMESPACE
    
    # Wait for deployment to be ready
    log_info "Waiting for deployment to be ready..."
    kubectl wait --for=condition=available --timeout=300s deployment/flask-app -n $NAMESPACE
    
    log_info "Application deployed successfully ✅"
}

# Get service information
get_service_info() {
    log_info "Getting service information..."
    
    echo ""
    echo "📋 Service Details:"
    kubectl get svc -n $NAMESPACE
    
    echo ""
    echo "🔍 Pod Status:"
    kubectl get pods -n $NAMESPACE
    
    echo ""
    echo "📊 HPA Status:"
    kubectl get hpa -n $NAMESPACE 2>/dev/null || log_warn "HPA not found"
    
    # Get LoadBalancer URL
    EXTERNAL_IP=$(kubectl get svc flask-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
    if [ ! -z "$EXTERNAL_IP" ]; then
        echo ""
        log_info "🌐 Application URL: http://$EXTERNAL_IP"
    else
        log_warn "LoadBalancer external IP not yet assigned"
    fi
}

# Main execution
main() {
    echo "======================================="
    echo "   Flask App EKS Deployment Script"
    echo "======================================="
    echo ""
    
    check_prerequisites
    deploy_app
    get_service_info
    
    echo ""
    log_info "Deployment completed! 🎉"
    echo ""
    echo "Next steps:"
    echo "- Monitor: kubectl get pods -n $NAMESPACE -w"
    echo "- Logs: kubectl logs -f deployment/flask-app -n $NAMESPACE"
    echo "- Scale: kubectl scale deployment flask-app --replicas=5 -n $NAMESPACE"
}

# Run main function
main "$@"

---
# scripts/cleanup.sh - Cleanup script
#!/bin/bash
set -e

echo "🧹 Cleaning up Flask App deployment..."

NAMESPACE=${NAMESPACE:-flask-app}
CLUSTER_NAME=${CLUSTER_NAME:-flask-app-cluster}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Delete application resources
delete_app() {
    log_info "Deleting application resources from namespace: $NAMESPACE"
    
    if kubectl get namespace $NAMESPACE >/dev/null 2>&1; then
        kubectl delete -f k8s/ -n $NAMESPACE --ignore-not-found=true
        kubectl delete namespace $NAMESPACE --ignore-not-found=true
        log_info "Application resources deleted ✅"
    else
        log_warn "Namespace $NAMESPACE not found"
    fi
}

# Delete cluster (optional)
delete_cluster() {
    read -p "Do you want to delete the EKS cluster '$CLUSTER_NAME'? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_warn "Deleting EKS cluster: $CLUSTER_NAME"
        eksctl delete cluster --name $CLUSTER_NAME
        log_info "Cluster deleted ✅"
    else
        log_info "Cluster preserved"
    fi
}

main() {
    echo "======================================="
    echo "     Flask App Cleanup Script"
    echo "======================================="
    echo ""
    
    delete_app
    echo ""
    delete_cluster
    
    echo ""
    log_info "Cleanup completed! 🎉"
}

main "$@"

---
# scripts/test-endpoints.sh - Test application endpoints
#!/bin/bash

# Configuration
NAMESPACE=${NAMESPACE:-flask-app}
SERVICE_NAME=${SERVICE_NAME:-flask-service}

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Get service URL
get_service_url() {
    # Try external LoadBalancer first
    EXTERNAL_URL=$(kubectl get svc $SERVICE_NAME -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
    
    if [ ! -z "$EXTERNAL_URL" ]; then
        SERVICE_URL="http://$EXTERNAL_URL"
    else
        # Fall back to port-forward
        log_info "Using port-forward for testing..."
        kubectl port-forward svc/$SERVICE_NAME -n $NAMESPACE 8080:80 >/dev/null 2>&1 &
        PORT_FORWARD_PID=$!
        sleep 3
        SERVICE_URL="http://localhost:8080"
    fi
    
    echo $SERVICE_URL
}

# Test endpoint
test_endpoint() {
    local endpoint=$1
    local expected_status=$2
    local method=${3:-GET}
    
    echo -n "Testing $method $endpoint ... "
    
    if [ "$method" = "POST" ]; then
        response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" -d '{"test": "data"}' "$SERVICE_URL$endpoint" -o /dev/null)
    else
        response=$(curl -s -w "%{http_code}" "$SERVICE_URL$endpoint" -o /dev/null)
    fi
    
    if [ "$response" = "$expected_status" ]; then
        echo -e "${GREEN}✅ PASS${NC}"
    else
        echo -e "${RED}❌ FAIL (Expected: $expected_status, Got: $response)${NC}"
    fi
}

# Main testing function
run_tests() {
    log_info "Getting service URL..."
    SERVICE_URL=$(get_service_url)
    log_info "Testing endpoints at: $SERVICE_URL"
    echo ""
    
    # Test all endpoints
    test_endpoint "/" "200"
    test_endpoint "/health" "200"
    test_endpoint "/ready" "200"
    test_endpoint "/metrics" "200"
    test_endpoint "/info" "200"
    test_endpoint "/echo" "200" "POST"
    test_endpoint "/nonexistent" "404"
    
    echo ""
    log_info "Endpoint tests completed!"
    
    # Cleanup port-forward if used
    if [ ! -z "$PORT_FORWARD_PID" ]; then
        kill $PORT_FORWARD_PID 2>/dev/null || true
    fi
}

main() {
    echo "======================================="
    echo "    Flask App Endpoint Tests"
    echo "======================================="
    echo ""
    
    # Check if service exists
    if ! kubectl get svc $SERVICE_NAME -n $NAMESPACE >/dev/null 2>&1; then
        log_error "Service '$SERVICE_NAME' not found in namespace '$NAMESPACE'"
        exit 1
    fi
    
    run_tests
}

main "$@"

---
# .github/workflows/ci-cd.yml - GitHub Actions workflow (optional)
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov
    
    - name: Run tests
      run: |
        pytest tests/ -v --cov=app
    
    - name: Lint with flake8
      run: |
        pip install flake8
        flake8 app.py --count --select=E9,F63,F7,F82 --show-source --statistics

  build:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}

---
# Makefile - Common development tasks
.PHONY: help build run test deploy clean

# Default target
help:
	@echo "Available targets:"
	@echo "  build     - Build Docker image"
	@echo "  run       - Run application locally"
	@echo "  test      - Run tests"
	@echo "  deploy    - Deploy to EKS"
	@echo "  clean     - Clean up resources"
	@echo "  lint      - Run code linting"

# Variables
IMAGE_NAME ?= flask-eks-app
IMAGE_TAG ?= latest
NAMESPACE ?= flask-app

build:
	@echo "Building Docker image..."
	docker build -t $(IMAGE_NAME):$(IMAGE_TAG) .

run:
	@echo "Running application locally..."
	python app.py

test:
	@echo "Running tests..."
	python -m pytest tests/ -v

deploy:
	@echo "Deploying to EKS..."
	./scripts/deploy.sh

clean:
	@echo "Cleaning up..."
	./scripts/cleanup.sh

lint:
	@echo "Running linting..."
	flake8 app.py
	pylint app.py

# Docker commands
docker-run:
	docker run -p 5000:5000 $(IMAGE_NAME):$(IMAGE_TAG)

docker-push:
	docker push $(IMAGE_NAME):$(IMAGE_TAG)

# Kubernetes commands
k8s-logs:
	kubectl logs -f deployment/flask-app -n $(NAMESPACE)

k8s-shell:
	kubectl exec -it deployment/flask-app -n $(NAMESPACE) -- /bin/bash

k8s-scale:
	kubectl scale deployment flask-app --replicas=5 -n $(NAMESPACE)
